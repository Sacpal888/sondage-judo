<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG ‚Üí APNG Converter (Optimis√©)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 700px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 28px;
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
            border: 2px solid #e0e4ff;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title > span:first-child {
            flex-shrink: 0;
        }

        .section-title > span:nth-child(2) {
            flex: 1;
        }

        .btn-reset-small {
            padding: 6px 12px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .btn-reset-small:hover {
            background: #ee5a52;
            transform: scale(1.05);
        }

        .section-description {
            font-size: 13px;
            color: #666;
            margin-bottom: 15px;
        }

        .upload-zone {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 30px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .upload-zone:hover {
            border-color: #764ba2;
            background: #fafbff;
        }

        .upload-zone.dragover {
            border-color: #764ba2;
            background: #f0f1ff;
            transform: scale(1.02);
        }

        .upload-zone.has-files {
            border-color: #4caf50;
            background: #f1f8f4;
        }

        .upload-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .upload-text {
            color: #667eea;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .upload-hint {
            color: #999;
            font-size: 12px;
        }

        .upload-count {
            color: #4caf50;
            font-size: 13px;
            font-weight: 600;
            margin-top: 8px;
        }

        input[type="file"] {
            display: none;
        }

        .freeze-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .freeze-input {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .freeze-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .freeze-label {
            color: #666;
            font-size: 13px;
            font-weight: 500;
        }

        .options {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .option-group {
            margin-bottom: 15px;
        }

        .option-group:last-child {
            margin-bottom: 0;
        }

        .option-label {
            display: block;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .framerate-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .framerate-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        .framerate-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
        }

        .framerate-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .framerate-value {
            min-width: 70px;
            text-align: center;
            font-weight: 600;
            color: #667eea;
            font-size: 16px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle input:checked + .toggle-slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-label {
            color: #333;
            font-size: 14px;
        }

        .actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-convert {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-convert:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-convert:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-clear {
            background: #f0f0f0;
            color: #666;
        }

        .btn-clear:hover {
            background: #e0e0e0;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .progress {
            margin-top: 15px;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            display: none;
        }

        .progress.show {
            display: block;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0;
            transition: width 0.3s ease;
        }

        .info-box {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            border-radius: 4px;
            font-size: 13px;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéûÔ∏è PNG ‚Üí APNG (Optimis√©)</h1>
        <p class="subtitle">Animation avec freeze optimis√© pour √©conomiser la m√©moire</p>

        <div class="info-box">
            üí° <strong>Astuce :</strong> Toutes les sections sont optionnelles ! Vous pouvez uploader uniquement l'intro, ou intro + freeze, ou toute autre combinaison. La boucle s'applique √† l'ensemble s√©lectionn√©.
        </div>

        <!-- Section 1: Animation d'entr√©e -->
        <div class="section">
            <div class="section-title">
                <span>üé¨</span>
                <span>Animation d'entr√©e</span>
                <button class="btn-reset-small" id="resetIntro" style="display: none;">üóëÔ∏è Reset</button>
            </div>
            <div class="section-description">Images qui s'animeront au d√©but (optionnel)</div>
            <div class="upload-zone" id="uploadZoneIntro">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">Glissez vos PNG ici</div>
                <div class="upload-hint">ou cliquez pour s√©lectionner</div>
            </div>
            <input type="file" id="fileInputIntro" accept="image/png" multiple>
            <div class="upload-count" id="countIntro"></div>
        </div>

        <!-- Section 2: Image freeze -->
        <div class="section">
            <div class="section-title">
                <span>‚è∏Ô∏è</span>
                <span>Image freeze (pause)</span>
                <button class="btn-reset-small" id="resetFreeze" style="display: none;">üóëÔ∏è Reset</button>
            </div>
            <div class="section-description">Une seule image qui restera affich√©e pendant X secondes (optionnel)</div>
            <div class="upload-zone" id="uploadZoneFreeze">
                <div class="upload-icon">üñºÔ∏è</div>
                <div class="upload-text">1 seule image PNG</div>
                <div class="upload-hint">Image qui sera fig√©e</div>
            </div>
            <input type="file" id="fileInputFreeze" accept="image/png">
            <div class="upload-count" id="countFreeze"></div>
            <div class="freeze-controls">
                <span class="freeze-label">Dur√©e du freeze :</span>
                <input type="number" class="freeze-input" id="freezeDuration" min="0" max="3600" value="3" step="0.5">
                <span class="freeze-label">secondes</span>
            </div>
        </div>

        <!-- Section 3: Animation de sortie -->
        <div class="section">
            <div class="section-title">
                <span>üé¨</span>
                <span>Animation de sortie</span>
                <button class="btn-reset-small" id="resetOutro" style="display: none;">üóëÔ∏è Reset</button>
            </div>
            <div class="section-description">Images qui s'animeront √† la fin (optionnel)</div>
            <div class="upload-zone" id="uploadZoneOutro">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">Glissez vos PNG ici</div>
                <div class="upload-hint">ou cliquez pour s√©lectionner</div>
            </div>
            <input type="file" id="fileInputOutro" accept="image/png" multiple>
            <div class="upload-count" id="countOutro"></div>
        </div>

        <!-- Options globales -->
        <div class="options">
            <div class="option-group">
                <label class="option-label">Frame Rate (FPS) - pour les animations</label>
                <div class="framerate-container">
                    <input type="range" class="framerate-slider" id="framerateSlider" min="1" max="120" value="50">
                    <div class="framerate-value"><span id="framerateValue">50</span> fps</div>
                </div>
            </div>

            <div class="option-group">
                <label class="option-label">Boucle infinie</label>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="infiniteLoop" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="toggle-label" id="loopLabel">Activ√©e</span>
                </div>
            </div>
        </div>

        <div class="actions">
            <button class="btn-convert" id="convertBtn" disabled>Convertir en APNG</button>
            <button class="btn-clear" id="clearBtn">Effacer tout</button>
        </div>

        <div class="progress" id="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="status" id="status"></div>
    </div>

    <!-- IMPORTANT : pako.js doit √™tre charg√© AVANT UPNG.js -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
    <script>
        // ==== Utilitaire : forcer le nombre de lectures APNG (patch du chunk acTL) ====
        function setApngNumPlays(buf, plays) {
            const bytes = new Uint8Array(buf);
            let p = 8; // signature PNG (8 octets)

            const readU32 = (o) => (bytes[o] << 24) | (bytes[o+1] << 16) | (bytes[o+2] << 8) | bytes[o+3];
            const writeU32 = (o, v) => { bytes[o] = v >>> 24; bytes[o+1] = (v >>> 16) & 255; bytes[o+2] = (v >>> 8) & 255; bytes[o+3] = v & 255; };

            // CRC32 table
            const table = (() => { let t = [], c; for (let n = 0; n < 256; n++) { c = n; for (let k = 0; k < 8; k++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1); t[n] = c >>> 0; } return t; })();
            const crc32 = (arr) => { let c = ~0; for (let i = 0; i < arr.length; i++) c = (c >>> 8) ^ table[(c ^ arr[i]) & 0xFF]; return (~c) >>> 0; };

            while (p < bytes.length) {
                const len = readU32(p);
                const type = String.fromCharCode(bytes[p+4], bytes[p+5], bytes[p+6], bytes[p+7]);
                if (type === 'acTL') {
                    // acTL: [num_frames(4)][num_plays(4)]
                    writeU32(p + 8 + 4, plays); // num_plays
                    const start = p + 4;  // type + data
                    const end   = p + 8 + len;
                    const newCrc = crc32(bytes.slice(start, end));
                    writeU32(end, newCrc);
                    return bytes.buffer;
                }
                p += 12 + len; // len(4)+type(4)+data(len)+crc(4)
            }
            return buf; // pas d'acTL ‚Üí PNG non anim√©
        }

        // ==== √âl√©ments DOM ====
        const uploadZoneIntro = document.getElementById('uploadZoneIntro');
        const uploadZoneFreeze = document.getElementById('uploadZoneFreeze');
        const uploadZoneOutro = document.getElementById('uploadZoneOutro');
        const fileInputIntro = document.getElementById('fileInputIntro');
        const fileInputFreeze = document.getElementById('fileInputFreeze');
        const fileInputOutro = document.getElementById('fileInputOutro');
        const countIntro = document.getElementById('countIntro');
        const countFreeze = document.getElementById('countFreeze');
        const countOutro = document.getElementById('countOutro');
        const freezeDuration = document.getElementById('freezeDuration');
        const framerateSlider = document.getElementById('framerateSlider');
        const framerateValue = document.getElementById('framerateValue');
        const infiniteLoop = document.getElementById('infiniteLoop');
        const loopLabel = document.getElementById('loopLabel');
        const convertBtn = document.getElementById('convertBtn');
        const clearBtn = document.getElementById('clearBtn');
        const resetIntro = document.getElementById('resetIntro');
        const resetFreeze = document.getElementById('resetFreeze');
        const resetOutro = document.getElementById('resetOutro');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const progressBar = document.getElementById('progressBar');

        let introFiles = [];
        let freezeFile = null;
        let outroFiles = [];

        // Setup upload zones
        setupUploadZone(uploadZoneIntro, fileInputIntro, 'intro');
        setupUploadZone(uploadZoneFreeze, fileInputFreeze, 'freeze');
        setupUploadZone(uploadZoneOutro, fileInputOutro, 'outro');

        function setupUploadZone(zone, input, type) {
            zone.addEventListener('click', () => input.click());

            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');
                handleFiles(e.dataTransfer.files, type);
            });

            input.addEventListener('change', (e) => {
                handleFiles(e.target.files, type);
            });
        }

        function handleFiles(files, type) {
            const pngFiles = Array.from(files).filter(file => file.type === 'image/png');
            
            if (pngFiles.length === 0) {
                showStatus('Veuillez s√©lectionner des fichiers PNG uniquement', 'error');
                return;
            }

            if (type === 'intro') {
                introFiles = pngFiles.sort((a, b) => a.name.localeCompare(b.name));
                updateCount(countIntro, uploadZoneIntro, introFiles.length, 'intro');
            } else if (type === 'freeze') {
                freezeFile = pngFiles[0];
                updateCount(countFreeze, uploadZoneFreeze, 1, 'freeze');
            } else if (type === 'outro') {
                outroFiles = pngFiles.sort((a, b) => a.name.localeCompare(b.name));
                updateCount(countOutro, uploadZoneOutro, outroFiles.length, 'outro');
            }

            checkCanConvert();
            hideStatus();
        }

        function updateCount(element, zone, count, type) {
            let resetBtn;
            if (type === 'intro') resetBtn = resetIntro;
            else if (type === 'freeze') resetBtn = resetFreeze;
            else if (type === 'outro') resetBtn = resetOutro;

            if (count > 0) {
                const label = type === 'freeze' ? '1 image s√©lectionn√©e' : `${count} image${count > 1 ? 's' : ''} s√©lectionn√©e${count > 1 ? 's' : ''}`;
                element.textContent = `‚úì ${label}`;
                element.style.display = 'block';
                zone.classList.add('has-files');
                if (resetBtn) resetBtn.style.display = 'inline-block';
            } else {
                element.textContent = '';
                element.style.display = 'none';
                zone.classList.remove('has-files');
                if (resetBtn) resetBtn.style.display = 'none';
            }
        }

        function checkCanConvert() {
            // On peut convertir si on a au moins une section remplie
            convertBtn.disabled = !(introFiles.length > 0 || freezeFile || outroFiles.length > 0);
        }

        // Framerate slider
        framerateSlider.addEventListener('input', (e) => {
            framerateValue.textContent = e.target.value;
        });

        // Infinite loop toggle
        infiniteLoop.addEventListener('change', (e) => {
            loopLabel.textContent = e.target.checked ? 'Activ√©e' : 'D√©sactiv√©e';
        });

        // Reset buttons individuels
        resetIntro.addEventListener('click', () => {
            introFiles = [];
            fileInputIntro.value = '';
            updateCount(countIntro, uploadZoneIntro, 0, 'intro');
            checkCanConvert();
        });

        resetFreeze.addEventListener('click', () => {
            freezeFile = null;
            fileInputFreeze.value = '';
            updateCount(countFreeze, uploadZoneFreeze, 0, 'freeze');
            checkCanConvert();
        });

        resetOutro.addEventListener('click', () => {
            outroFiles = [];
            fileInputOutro.value = '';
            updateCount(countOutro, uploadZoneOutro, 0, 'outro');
            checkCanConvert();
        });

        // Clear button - tout effacer
        clearBtn.addEventListener('click', () => {
            introFiles = [];
            freezeFile = null;
            outroFiles = [];
            fileInputIntro.value = '';
            fileInputFreeze.value = '';
            fileInputOutro.value = '';
            updateCount(countIntro, uploadZoneIntro, 0, 'intro');
            updateCount(countFreeze, uploadZoneFreeze, 0, 'freeze');
            updateCount(countOutro, uploadZoneOutro, 0, 'outro');
            convertBtn.disabled = true;
            hideStatus();
            hideProgress();
        });

        // Outil de t√©l√©chargement g√©n√©rique
        function triggerDownloadFromBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function triggerDownloadFromFile(file, filename) {
            const url = URL.createObjectURL(file);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        // Convert button
        convertBtn.addEventListener('click', async () => {
            // V√©rifier qu'on a au moins une section remplie
            if (introFiles.length === 0 && !freezeFile && outroFiles.length === 0) {
                showStatus('Veuillez s√©lectionner au moins une section (intro, freeze ou outro)', 'error');
                return;
            }

            convertBtn.disabled = true;
            showStatus('Chargement des images...', 'info');
            showProgress();

            try {
                const frames = [];
                const delays = [];
                const fps = parseInt(framerateSlider.value);
                const freezeDurationSec = parseFloat(freezeDuration.value);
                const delayPerFrame = 1000 / fps;

                let width = 0;
                let height = 0;
                let totalFrames = 0;
                const totalToProcess = introFiles.length + (freezeFile ? 1 : 0) + outroFiles.length;

                // 1. Charger l'animation d'entr√©e (si pr√©sente)
                if (introFiles.length > 0) {
                    showStatus(`Chargement animation d'entr√©e (${introFiles.length} images)...`, 'info');
                    for (let i = 0; i < introFiles.length; i++) {
                        updateProgress((totalFrames / totalToProcess) * 100);
                        
                        const imageData = await loadImageData(introFiles[i]);
                        if (totalFrames === 0) {
                            width = imageData.width;
                            height = imageData.height;
                        }
                        frames.push(imageData.buffer);
                        delays.push(delayPerFrame);
                        totalFrames++;
                    }
                }

                // 2. Charger l'image freeze (si pr√©sente)
                if (freezeFile) {
                    showStatus('Chargement de l\'image freeze...', 'info');
                    updateProgress((totalFrames / totalToProcess) * 100);
                    
                    const freezeImageData = await loadImageData(freezeFile);
                    if (totalFrames === 0) {
                        width = freezeImageData.width;
                        height = freezeImageData.height;
                    }
                    
                    // Ajouter l'image freeze avec le d√©lai sp√©cifi√©
                    const freezeDelay = freezeDurationSec > 0 ? (freezeDurationSec * 1000) : delayPerFrame;
                    frames.push(freezeImageData.buffer);
                    delays.push(freezeDelay);
                    totalFrames++;
                }

                // 3. Charger l'animation de sortie (si pr√©sente)
                if (outroFiles.length > 0) {
                    showStatus(`Chargement animation de sortie (${outroFiles.length} images)...`, 'info');
                    for (let i = 0; i < outroFiles.length; i++) {
                        updateProgress((totalFrames / totalToProcess) * 100);
                        
                        const imageData = await loadImageData(outroFiles[i]);
                        if (totalFrames === 0) {
                            width = imageData.width;
                            height = imageData.height;
                        }
                        frames.push(imageData.buffer);
                        delays.push(delayPerFrame);
                        totalFrames++;
                    }
                }

                updateProgress(100);

                // === Cas sp√©cial : seulement un freeze sans intro/outro ‚Üí PNG statique (pas d'APNG) ===
                if (introFiles.length === 0 && outroFiles.length === 0 && freezeFile && totalFrames === 1) {
                    showStatus('Export PNG statique (aucune animation)...', 'info');
                    // On r√©utilise directement le fichier PNG fourni par l'utilisateur
                    triggerDownloadFromFile(freezeFile, 'freeze.png');
                    const composition = [`freeze ${freezeDurationSec}s`];
                    showStatus(`‚úÖ PNG export√© (statique). (${composition.join(' + ')}, ${width}x${height}px)`, 'success');
                    hideProgress();
                    convertBtn.disabled = false;
                    return;
                }

                showStatus('Cr√©ation de l\'APNG (compression en cours)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 100));

                // Cr√©er l'APNG (upng-js n'accepte pas "loopCount" en 6√®me param√®tre)
                let apng = UPNG.encode(frames, width, height, 256, delays);

                // Forcer le nombre de lectures dans le chunk acTL
                if (infiniteLoop.checked) {
                    apng = setApngNumPlays(apng, 0); // 0 = boucle infinie (sp√©cification APNG)
                } else {
                    apng = setApngNumPlays(apng, 1); // 1 = lecture unique
                }
                
                // T√©l√©charger le fichier
                const blob = new Blob([apng], { type: 'image/apng' });
                triggerDownloadFromBlob(blob, 'animation.apng');

                const loopText = infiniteLoop.checked ? 'boucle infinie' : 'lecture unique';
                const fileSize = formatFileSize(blob.size);
                const composition = [];
                if (introFiles.length > 0) composition.push(`${introFiles.length} intro`);
                if (freezeFile) composition.push(`freeze ${freezeDurationSec}s`);
                if (outroFiles.length > 0) composition.push(`${outroFiles.length} outro`);

                showStatus(`‚úÖ APNG cr√©√© ! (${composition.join(' + ')}, ${totalFrames} frames, ${width}x${height}px, ${fileSize}, ${loopText})`, 'success');
                hideProgress();

            } catch (error) {
                showStatus('‚ùå Erreur : ' + error.message, 'error');
                console.error(error);
                hideProgress();
            } finally {
                convertBtn.disabled = false;
            }
        });

        async function loadImageData(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const reader = new FileReader();

                reader.onload = (e) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        resolve({
                            buffer: imageData.data.buffer,
                            width: canvas.width,
                            height: canvas.height
                        });
                    };
                    img.onerror = () => reject(new Error('Erreur de chargement de l\'image'));
                    img.src = e.target.result;
                };

                reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
                reader.readAsDataURL(file);
            });
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status show ' + type;
        }

        function hideStatus() {
            status.classList.remove('show');
        }

        function showProgress() {
            progress.classList.add('show');
        }

        function hideProgress() {
            progress.classList.remove('show');
            progressBar.style.width = '0';
        }

        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
        }
    </script>
</body>
</html>
